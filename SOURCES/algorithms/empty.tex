% empty.tex
\nopagenumbers
\parskip=2pt
\parindent=0pt

{\sl An Iterative Algorithm for Emptying a Binary Tree
	\hfill \rm Farooq Mela $<$farooq.mela@gmail.com$>$}

\medskip

\noindent {\bf Algorithm E} ({\it Empty Binary Tree}).
Given a set of nodes which form a binary tree {\tt T}, this algorithm will
empty the entire tree and free its storage. Each node is assumed to contain
{\tt LEFT}, {\tt RIGHT}, and {\tt PARENT} fields. {\tt LEFT} and {\tt RIGHT}
are pointers to the node's left and right subtree, respectively, and {\tt
PARENT} is a pointer to the node of which it is a child. Any of these three
fields may be $\Lambda$, which for {\tt LEFT} and {\tt RIGHT} indicates that
there is no left or right subtree, respectively, and for {\tt PARENT} indicates
that is the that the node is root of the tree. The tree has a field {\tt ROOT}
which is a pointer to the root node of the tree.

This algorithm makes use of two pointer-to-nodes {\tt N} and {\tt P}.

\medskip
You can find an implementation of this algorithm, as well as many others, in
{\bf libdict}, which is available on the web at
{\tt http://github.com/fmela/libdict}.
\medskip
\parindent=36pt

\item{\bf E1.} [Initialize]
Set ${\tt N} \gets {\tt ROOT(T)}$.

\item{\bf E2.} [Are we done yet?]
If ${\tt N} = \Lambda$, set ${\tt ROOT(T)} \gets \Lambda$.
The tree is now empty and the algorithm terminates.
Otherwise, set ${\tt P} \gets {\tt PARENT(N)}.$

\item{\bf E3.} [Can we move left?]
If ${\tt LEFT(N)} \neq \Lambda$, set ${\tt N} \gets {\tt LEFT(N)}$, and
go to step E2.

\item{\bf E4.} [Can we move right?]
If ${\tt RIGHT(N)} \neq \Lambda$, set ${\tt N} \gets {\tt RIGHT(N)}$, and
go to step E2.

\item{\bf E5.} [Release node]
{\tt N} is now a leaf; release its storage.
If ${\tt RIGHT(P)} = {\tt N}$, set ${\tt RIGHT(P)} \gets \Lambda$.
Otherwise, set ${\tt LEFT(P)} \gets \Lambda$.

\item{\bf E6.} [Move up]
Set ${\tt N} \gets {\tt P}$, and go to step E2.

\medskip
\parindent=0pt
{\bf Notes on Algorithm E}
\parindent=36pt
\item{\bf 1.} This algorithm runs in $\Theta(n)$ time and makes use of constant
space. It does not make use of recursion, but it is still a simple and elegant
algorithm. These properties make it superior to algorithms which use an
auxiliary stack or recurse to perform the same operation.

\parindent=0pt
\medskip

\bye
% EOF
